@inject BookLoggerApp.Core.Services.Abstractions.IImageService ImageService

@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div class="book-card @(IsInBookshelf ? "in-bookshelf-book" : "compact")"
     @onclick="HandleClick">
    <div @ref="_imageContainer" class="@(IsInBookshelf ? "book-cover-wrapper" : "book-cover-thumbnail")" style="@GetSpineStyle()">
        @if (!string.IsNullOrEmpty(_coverImageDataUrl) && (!IsInBookshelf || Book.UsesCoverAsSpine))
        {
                <img src="@_coverImageDataUrl"
                     alt="@Book.Title"
                     class="book-cover-image"
            @ondragstart:preventDefault="true" />
        }
    </div>

    @if (IsInBookshelf)
    {
            <!-- Spine view: title and author on the spine -->
            <div class="book-status-badge status-@Book.Status.ToString().ToLower()">
            @GetStatusIcon()
            </div>
            <div class="book-card-body">
                <h3 class="book-title">@Book.Title</h3>
                <p class="book-author">@Book.Author</p>
            </div>
        @if (Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Reading || Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Completed)
        {
                    <div class="book-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: @Book.ProgressPercentage%"></div>
                        </div>
                    </div>
        }
    }
    else
    {
            <!-- Compact card view: horizontal layout -->
            <div class="book-card-content">
                <div class="book-card-header">
                    <div class="book-status-badge status-@Book.Status.ToString().ToLower()">
                    @GetStatusIcon()
                    </div>
                    <button class="btn-icon-compact" @onclick:stopPropagation="true" @onclick="HandleDelete" title="Delete">
                        üóëÔ∏è
                    </button>
                </div>
                <h3 class="book-title">@Book.Title</h3>
                <p class="book-author">@Book.Author</p>
            @if (Book.AverageRating.HasValue)
            {
                        <div class="book-rating">
                    @{
                        var rating = (int)Math.Round(Book.AverageRating.Value);
                    }
                    @for (int i = 1; i <= 5; i++)
                    {
                                    <span class="star @(i <= rating ? "filled" : "empty")">‚òÖ</span>
                    }
                        </div>
            }
            @if (Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Reading || Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Completed)
            {
                        <div class="book-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: @Book.ProgressPercentage%"></div>
                            </div>
                        </div>
            }
            </div>
    }
</div>

@code {
    [Parameter] public BookLoggerApp.Core.Models.Book Book { get; set; } = null!;
    [Parameter] public EventCallback OnClick { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback OnQuickTimer { get; set; }
    [Parameter] public bool IsInBookshelf { get; set; }
    private string? _coverImageDataUrl;
    private Guid _lastBookId;

    // Lazy loading
    private ElementReference _imageContainer;
    private DotNetObjectReference<BookCard>? _dotNetHelper;
    private bool _isImageLoaded = false;
    private bool _observerRegistered = false;

    // ShouldRender optimization: skip Blazor diff when parameters haven't meaningfully changed
    private bool _shouldRender = true;

    protected override bool ShouldRender() => _shouldRender;

    protected override void OnInitialized()
    {
        // Don't auto-load image here anymore. Wait for observer.
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ! _observerRegistered)
        {
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("lazyLoading.observe", _imageContainer, _dotNetHelper);
            _observerRegistered = true;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Only reload if book changed
        if (Book != null && Book.Id != _lastBookId)
        {
            _shouldRender = true;
            _lastBookId = Book.Id;
            // Reset state for new book
            _isImageLoaded = false;
            _coverImageDataUrl = null;

            // Re-observe if we swapped books (observer unobserves after trigger)
             if (_observerRegistered && _dotNetHelper != null)
             {
                 await JSRuntime.InvokeVoidAsync("lazyLoading.observe", _imageContainer, _dotNetHelper);
             }
        }
        else
        {
            _shouldRender = false;
        }
    }

    [JSInvokable]
    public async Task LoadImage()
    {
        if (_isImageLoaded) return;

        await LoadCoverImageAsync();
        _isImageLoaded = true;
        _shouldRender = true;
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadCoverImageAsync()
    {
        _coverImageDataUrl = null;

        if (Book == null || string.IsNullOrEmpty(Book.CoverImagePath))
            return;

        try
        {
            var coverPath = Book.CoverImagePath;

            // If it's already a URL (http/https), use it directly
            if (coverPath.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                coverPath.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
            {
                _coverImageDataUrl = coverPath;
                return;
            }

            // Get resized image from service (automatically cached as thumbnail)
            var result = await ImageService.GetResizedCoverImageAsync(Book.Id);
            if (result == null)
                return;

            var (bytes, mimeType) = result.Value;
            _coverImageDataUrl = $"data:{mimeType};base64,{Convert.ToBase64String(bytes)}";
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to load cover image for book {Book.Id}: {ex.Message}");
            _coverImageDataUrl = null;
        }
    }

    private string GetSpineStyle()
    {
        // If lazy loaded image is ready (and using cover as spine)
        if (_isImageLoaded && Book.UsesCoverAsSpine && !string.IsNullOrEmpty(_coverImageDataUrl))
        {
            return $"background-image: url('{_coverImageDataUrl}'); background-size: cover; background-position: center;";
        }
        
        // Use centralized helper for colors
        var (dark, light) = BookLoggerApp.Core.Helpers.SpineColorHelper.GetColors(Book.SpineColor, Book.Id);
        return $"background: linear-gradient(to right, #{dark}, #{light}, #{dark});";
    }

    private string GetStatusIcon()
    {
        return Book.Status switch
        {
            BookLoggerApp.Core.Models.ReadingStatus.Planned => "üìã",
            BookLoggerApp.Core.Models.ReadingStatus.Reading => "üìñ",
            BookLoggerApp.Core.Models.ReadingStatus.Completed => "‚úÖ",
            BookLoggerApp.Core.Models.ReadingStatus.Abandoned => "‚ùå",
            BookLoggerApp.Core.Models.ReadingStatus.Wishlist => "üíù",
            _ => ""
        };
    }

    private async Task HandleClick()
    {
        await OnClick.InvokeAsync();
    }

    private async Task HandleDelete()
    {
        await OnDelete.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        try 
        {
            if (_observerRegistered)
            {
                await JSRuntime.InvokeVoidAsync("lazyLoading.unobserve", _imageContainer);
            }
            _dotNetHelper?.Dispose();
        }
        catch (Exception ex)
        {
            // Ignore disposal errors (e.g. if JS runtime is gone)
            System.Diagnostics.Debug.WriteLine($"Error disposing BookCard: {ex.Message}");
        }
    }
}

