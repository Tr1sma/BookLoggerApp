@inject BookLoggerApp.Core.Services.Abstractions.IImageService ImageService

<div class="book-card @(IsInBookshelf ? "in-bookshelf-book" : "compact") @(IsInBookshelf ? "" : "")"
     draggable="@(IsDraggable ? "true" : "false")"
@onclick="HandleClick"
@ondragstart="HandleDragStartInternal"
@ondragend="HandleDragEnd">
    <div class="@(IsInBookshelf ? "book-cover-wrapper" : "book-cover-thumbnail")" style="@GetSpineStyle()">
        @if (!string.IsNullOrEmpty(_coverImageDataUrl) && (!IsInBookshelf || Book.UsesCoverAsSpine))
        {
                <img src="@_coverImageDataUrl"
                     alt="@Book.Title"
                     class="book-cover-image"
            @ondragstart:preventDefault="true" />
        }
    </div>

    @if (IsInBookshelf)
    {
            <!-- Spine view: title and author on the spine -->
            <div class="book-status-badge status-@Book.Status.ToString().ToLower()">
            @GetStatusIcon()
            </div>
            <div class="book-card-body">
                <h3 class="book-title">@Book.Title</h3>
                <p class="book-author">@Book.Author</p>
            </div>
        @if (Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Reading || Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Completed)
        {
                    <div class="book-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: @Book.ProgressPercentage%"></div>
                        </div>
                    </div>
        }
    }
    else
    {
            <!-- Compact card view: horizontal layout -->
            <div class="book-card-content">
                <div class="book-card-header">
                    <div class="book-status-badge status-@Book.Status.ToString().ToLower()">
                    @GetStatusIcon()
                    </div>
                    <button class="btn-icon-compact" @onclick:stopPropagation="true" @onclick="HandleDelete" title="Delete">
                        üóëÔ∏è
                    </button>
                </div>
                <h3 class="book-title">@Book.Title</h3>
                <p class="book-author">@Book.Author</p>
            @if (Book.AverageRating.HasValue)
            {
                        <div class="book-rating">
                    @{
                        var rating = (int)Math.Round(Book.AverageRating.Value);
                    }
                    @for (int i = 1; i <= 5; i++)
                    {
                                    <span class="star @(i <= rating ? "filled" : "empty")">‚òÖ</span>
                    }
                        </div>
            }
            @if (Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Reading || Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Completed)
            {
                        <div class="book-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: @Book.ProgressPercentage%"></div>
                            </div>
                        </div>
            }
            </div>
    }
</div>

@code {
    [Parameter] public BookLoggerApp.Core.Models.Book Book { get; set; } = null!;
    [Parameter] public EventCallback OnClick { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback OnQuickTimer { get; set; }
    [Parameter] public EventCallback OnDragStart { get; set; }
    [Parameter] public bool IsInBookshelf { get; set; }
    [Parameter] public bool IsDraggable { get; set; } = false;

    private bool _isDragging = false;
    private string? _coverImageDataUrl;
    private Guid _lastBookId;

    protected override async Task OnParametersSetAsync()
    {
        // Only reload if book changed
        if (Book != null && Book.Id != _lastBookId)
        {
            _lastBookId = Book.Id;
            await LoadCoverImageAsync();
        }
    }

    private async Task LoadCoverImageAsync()
    {
        _coverImageDataUrl = null;

        if (Book == null || string.IsNullOrEmpty(Book.CoverImagePath))
            return;

        try
        {
            var coverPath = Book.CoverImagePath;

            // If it's already a URL (http/https), use it directly
            if (coverPath.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                coverPath.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
            {
                _coverImageDataUrl = coverPath;
                return;
            }

            // Get the full path from ImageService
            var fullPath = await ImageService.GetCoverImagePathAsync(Book.Id);

            if (string.IsNullOrEmpty(fullPath) || !System.IO.File.Exists(fullPath))
                return;

            // Read the file and convert to Base64
            var imageBytes = await System.IO.File.ReadAllBytesAsync(fullPath);
            var base64 = Convert.ToBase64String(imageBytes);

            // Determine MIME type
            var mimeType = fullPath.EndsWith(".png", StringComparison.OrdinalIgnoreCase)
                ? "image/png"
                : "image/jpeg";

            _coverImageDataUrl = $"data:{mimeType};base64,{base64}";
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to load cover image for book {Book.Id}: {ex.Message}");
            _coverImageDataUrl = null;
        }
    }

    private string GetSpineStyle()
    {
        // If UsesCoverAsSpine is true and we have a cover image, use it as background
        if (Book.UsesCoverAsSpine && !string.IsNullOrEmpty(_coverImageDataUrl))
        {
            return $"background-image: url('{_coverImageDataUrl}'); background-size: cover; background-position: center;";
        }

        // Use centralized helper for colors
        var (dark, light) = BookLoggerApp.Core.Helpers.SpineColorHelper.GetColors(Book.SpineColor, Book.Id);
        return $"background: linear-gradient(to right, #{dark}, #{light}, #{dark});";
    }

    private string GetStatusIcon()
    {
        return Book.Status switch
        {
            BookLoggerApp.Core.Models.ReadingStatus.Planned => "üìã",
            BookLoggerApp.Core.Models.ReadingStatus.Reading => "üìñ",
            BookLoggerApp.Core.Models.ReadingStatus.Completed => "‚úÖ",
            BookLoggerApp.Core.Models.ReadingStatus.Abandoned => "‚ùå",
            _ => ""
        };
    }

    private async Task HandleClick()
    {
        // Don't trigger click if we were dragging
        if (_isDragging)
        {
            _isDragging = false;
            return;
        }
        await OnClick.InvokeAsync();
    }

    private async Task HandleDragStartInternal(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        if (!IsDraggable) return;

        System.Diagnostics.Debug.WriteLine($"BookCard: Drag started for book {Book.Title}");
        _isDragging = true;
        await OnDragStart.InvokeAsync();
    }

    private void HandleDragEnd(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        System.Diagnostics.Debug.WriteLine($"BookCard: Drag ended for book {Book.Title}");
        // Reset dragging flag after a short delay to prevent click
        _ = Task.Run(async () =>
        {
            await Task.Delay(100);
            _isDragging = false;
        });
    }

    private async Task HandleDelete()
    {
        await OnDelete.InvokeAsync();
    }
}

