@inject BookLoggerApp.Core.Services.Abstractions.IImageService ImageService

@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div class="book-card @(IsInBookshelf ? "in-bookshelf-book" : "compact")"
     @onclick="HandleClick">
    <div @ref="_imageContainer" class="@(IsInBookshelf ? "book-cover-wrapper" : "book-cover-thumbnail")" style="@GetSpineStyle()">
        @if (!string.IsNullOrEmpty(_coverImageDataUrl) && (!IsInBookshelf || Book.UsesCoverAsSpine))
        {
                <img src="@_coverImageDataUrl"
                     alt="@Book.Title"
                     class="book-cover-image"
            @ondragstart:preventDefault="true" />
        }
    </div>

    @if (IsInBookshelf)
    {
            <!-- Spine view: title and author on the spine -->
            <div class="book-status-badge status-@Book.Status.ToString().ToLower()">
            @GetStatusIcon()
            </div>
            <div class="book-card-body">
                <h3 class="book-title">@Book.Title</h3>
                <p class="book-author">@Book.Author</p>
            </div>
        @if (Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Reading || Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Completed)
        {
                    <div class="book-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: @Book.ProgressPercentage%"></div>
                        </div>
                    </div>
        }
    }
    else
    {
            <!-- Compact card view: horizontal layout -->
            <div class="book-card-content">
                <div class="book-card-header">
                    <div class="book-status-badge status-@Book.Status.ToString().ToLower()">
                    @GetStatusIcon()
                    </div>
                    <button class="btn-icon-compact" @onclick:stopPropagation="true" @onclick="HandleDelete" title="Delete">
                        üóëÔ∏è
                    </button>
                </div>
                <h3 class="book-title">@Book.Title</h3>
                <p class="book-author">@Book.Author</p>
            @if (Book.AverageRating.HasValue)
            {
                        <div class="book-rating">
                    @{
                        var rating = (int)Math.Round(Book.AverageRating.Value);
                    }
                    @for (int i = 1; i <= 5; i++)
                    {
                                    <span class="star @(i <= rating ? "filled" : "empty")">‚òÖ</span>
                    }
                        </div>
            }
            @if (Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Reading || Book.Status == BookLoggerApp.Core.Models.ReadingStatus.Completed)
            {
                        <div class="book-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: @Book.ProgressPercentage%"></div>
                            </div>
                        </div>
            }
            </div>
    }
</div>

@code {
    [Parameter] public BookLoggerApp.Core.Models.Book Book { get; set; } = null!;
    [Parameter] public EventCallback OnClick { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback OnQuickTimer { get; set; }
    [Parameter] public bool IsInBookshelf { get; set; }
    private string? _coverImageDataUrl;
    private Guid _lastBookId;
    
    // Lazy loading
    private ElementReference _imageContainer;
    private DotNetObjectReference<BookCard>? _dotNetHelper;
    private bool _isImageLoaded = false;
    private bool _observerRegistered = false;

    protected override void OnInitialized()
    {
        // Don't auto-load image here anymore. Wait for observer.
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ! _observerRegistered)
        {
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("lazyLoading.observe", _imageContainer, _dotNetHelper);
            _observerRegistered = true;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Only reload if book changed
        if (Book != null && Book.Id != _lastBookId)
        {
            _lastBookId = Book.Id;
            // Reset state for new book
            _isImageLoaded = false;
            _coverImageDataUrl = null;
            
            // If we already have an observer, we might need to re-trigger or simpler: just wait for scroll.
            // But if the element is already in view, the observer might not fire again if we don't reset it.
            // Actually, for a recycled component (virtualization), the element ref stays same but content changes.
            // But here we are NOT using virtualization for the shelf slots yet (grid), only maybe searching.
            // Safest: if we already fired, we might need to check visibility again? 
            // In Blazor, if parameters change, we might want to attempt load if we were already loaded?
            // Let's rely on the observer. If the ID changes, we reset _isImageLoaded.
            // If the element is currently visible, we might want to re-force load.
            // For now, let's just clear and wait for observer callback (or manual re-observe if needed).
            
            // Re-observe if we swapped books?
             if (_observerRegistered && _dotNetHelper != null)
             {
                 // Small delay to ensure render info is up to date?
                 // Actually, standard IntersectionObserver continues observing the element.
                 // But we unobserved it in JS after trigger!
                 // So we MUST re-observe.
                 await JSRuntime.InvokeVoidAsync("lazyLoading.observe", _imageContainer, _dotNetHelper);
             }
        }
    }

    [JSInvokable]
    public async Task LoadImage()
    {
        if (_isImageLoaded) return;

        await LoadCoverImageAsync();
        _isImageLoaded = true;
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadCoverImageAsync()
    {
        _coverImageDataUrl = null;

        if (Book == null || string.IsNullOrEmpty(Book.CoverImagePath))
            return;

        try
        {
            var coverPath = Book.CoverImagePath;

            // If it's already a URL (http/https), use it directly
            if (coverPath.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                coverPath.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
            {
                _coverImageDataUrl = coverPath;
                return;
            }

            // Get the full path from ImageService
            var fullPath = await ImageService.GetCoverImagePathAsync(Book.Id);

            if (string.IsNullOrEmpty(fullPath) || !System.IO.File.Exists(fullPath))
                return;

            // Read the file and convert to Base64
            // Optimization: if it is very large, maybe resize? (Future todo)
            var imageBytes = await System.IO.File.ReadAllBytesAsync(fullPath);
            var base64 = Convert.ToBase64String(imageBytes);

            // Determine MIME type
            var mimeType = fullPath.EndsWith(".png", StringComparison.OrdinalIgnoreCase)
                ? "image/png"
                : "image/jpeg";

            _coverImageDataUrl = $"data:{mimeType};base64,{base64}";
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to load cover image for book {Book.Id}: {ex.Message}");
            _coverImageDataUrl = null;
        }
    }

    private string GetSpineStyle()
    {
        // If lazy loaded image is ready (and using cover as spine)
        if (_isImageLoaded && Book.UsesCoverAsSpine && !string.IsNullOrEmpty(_coverImageDataUrl))
        {
            return $"background-image: url('{_coverImageDataUrl}'); background-size: cover; background-position: center;";
        }
        
        // Use centralized helper for colors
        var (dark, light) = BookLoggerApp.Core.Helpers.SpineColorHelper.GetColors(Book.SpineColor, Book.Id);
        return $"background: linear-gradient(to right, #{dark}, #{light}, #{dark});";
    }

    private string GetStatusIcon()
    {
        return Book.Status switch
        {
            BookLoggerApp.Core.Models.ReadingStatus.Planned => "üìã",
            BookLoggerApp.Core.Models.ReadingStatus.Reading => "üìñ",
            BookLoggerApp.Core.Models.ReadingStatus.Completed => "‚úÖ",
            BookLoggerApp.Core.Models.ReadingStatus.Abandoned => "‚ùå",
            BookLoggerApp.Core.Models.ReadingStatus.Wishlist => "üíù",
            _ => ""
        };
    }

    private async Task HandleClick()
    {
        await OnClick.InvokeAsync();
    }

    private async Task HandleDelete()
    {
        await OnDelete.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        try 
        {
            if (_observerRegistered)
            {
                await JSRuntime.InvokeVoidAsync("lazyLoading.unobserve", _imageContainer);
            }
            _dotNetHelper?.Dispose();
        }
        catch (Exception ex)
        {
            // Ignore disposal errors (e.g. if JS runtime is gone)
            System.Diagnostics.Debug.WriteLine($"Error disposing BookCard: {ex.Message}");
        }
    }
}

